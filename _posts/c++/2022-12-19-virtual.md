---
title: 基类与派生类构造和析构中混了虚函数和指针的顺序
tags: c++
sidebar:
  nav: cs
mathjax: true
key: 2022-12-19-virtual
aside:
    toc: true
---

一些从csdn那搬来的东西
<!--more-->

# 如果只创建基类对象
则只调用基类的构造函数和析构函数。会调用基类的虚函数，不会调用派生类的虚函数。


# 如果只创建派生类对象
则构造顺序为：先调用基类的构造函数，再调用派生类的构造函数，析构顺序为：先调用派生类的析构函数，再调用基类的析构函数。<br />
只会调用派生类的虚函数，不会调用基类的虚函数。

 >因为情况2没有在堆区开辟空间，函数结束之后，系统自动释放资源，不存在内存泄漏问题，和基类析构函数设置不设置为虚函数没有关系。

# 基类指针指向派生类对象
构造和析构顺序和情况2一样。<br />
构造顺序为：先调用基类的构造函数，再调用派生类的构造函数，析构顺序为：先调用派生类的析构函数，再调用基类的析构函数。<br />
但是和情况2不同的是，情况3发生了多态。而且必须将基类的析构函数设置为虚函数，否则delete基类的指针，只会调用基类的析构函数不会调用派生类的析构函数，即只会释放基类对象的资源，无法释放派生类的资源，从而导致内存泄漏。<br />
因为派生类重写了基类的虚函数，发生了多态，所以只会调用派生类的虚函数，不会调用基类的虚函数。<br/>

___

版权声明：本文为CSDN博主「发如雪Jay」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br />
原文链接：https://blog.csdn.net/weixin_45003868/article/details/126071567

___

<br />
好愤怒 和chatgpt大战三百回合最后收获的只有这个<br />
![5](https://cdn.jsdelivr.net/gh/xiaoshuu/img/Picgo/5.png)<br />
它真的很嘴硬 这辈子没见过这么嘴硬的东西 我都把代码摆它面前了它只要运行一下就知道它错了可是它还是很嘴硬 推荐在战争时期让这个ai替代人去接受拷打 这么嘴硬应该不会泄露出去啥的 大家也不用担心自己的职业被机器人取代了 建议openai下一步往这个方面发展